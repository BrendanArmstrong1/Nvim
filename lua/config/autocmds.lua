-- local M = {}
--
-- local count_bufs_by_type = function(loaded_only)
--   loaded_only = (loaded_only == nil and true or loaded_only)
--   local count = { normal = 0, acwrite = 0, help = 0, nofile = 0, nowrite = 0, quickfix = 0, terminal = 0, prompt = 0 }
--   local buftypes = vim.api.nvim_list_bufs()
--   for _, bufname in pairs(buftypes) do
--     if (not loaded_only) or vim.api.nvim_buf_is_loaded(bufname) then
--       local buftype = vim.api.nvim_buf_get_option(bufname, "buftype")
--       buftype = buftype ~= "" and buftype or "normal"
--       count[buftype] = count[buftype] + 1
--     end
--   end
--   return count
-- end
--
-- function M.close_buffer()
--   print(vim.inspect(vim.api.nvim_list_wins()))
--   -- local bufTable = count_bufs_by_type()
--   -- if bufTable.normal <= 1 then
--   --   vim.api.nvim_exec([[:q]], true)
--   -- else
--   --   vim.api.nvim_exec([[:bd]], true)
--   -- end
-- end
--
-- -- local function tab_win_closed(winnr)
-- --   local tabnr = vim.api.nvim_win_get_tabpage(winnr)
-- --   local tab_wins = vim.tbl_filter(function(w)
-- --     return w ~= winnr
-- --   end, vim.api.nvim_tabpage_list_wins(tabnr))
-- --   local tab_bufs = vim.tbl_map(vim.api.nvim_win_get_buf, tab_wins)
-- --   if #tab_bufs == 1 then -- if there is only 1 buffer left in the tab
-- --     local last_buf_info = vim.fn.getbufinfo(tab_bufs[1])[1]
-- --     if
-- --       last_buf_info.name:match(".*NvimTree_%d*$")
-- --       or last_buf_info.name:match(".*NeoTree$")
-- --       or last_buf_info.name:match(".*sh$")
-- --       or last_buf_info.name:match(".*sh$")
-- --     then -- and that buffer is nvim tree
-- --       vim.schedule(function()
-- --         if #vim.api.nvim_list_wins() == 1 then -- if its the last buffer in vim
-- --           vim.cmd("quit") -- then close all of vim
-- --         else -- else there are more tabs open
-- --           vim.api.nvim_win_close(tab_wins[1], true) -- then close only the tab
-- --         end
-- --       end)
-- --     end
-- --   end
-- -- end
--
-- vim.api.nvim_create_autocmd("WinLeave", {
--   callback = function()
--     M.close_buffer()
--   end,
--   nested = true,
-- })
